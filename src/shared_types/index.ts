import type { Principal } from "@dfinity/principal";

// Corresponds to Candid: variant { Blink, Nod, SayPhrase }
export enum PromptTypeUi {
  Blink = "Blink",
  Nod = "Nod",
  SayPhrase = "SayPhrase",
}

// Corresponds to Candid: record VerificationChallenge
export interface VerificationChallengeUi {
  id: string;
  prompt_type: { [key in PromptTypeUi]?: null }; // Variant representation
  prompt_text: string;
  nonce: string;
}

// Corresponds to Candid: record VerificationSubmission
export interface VerificationSubmissionUi {
  challenge_id: string;
  mock_data: string;
  client_timestamp: bigint; // nat64 maps to bigint in JS
  encrypted_biometric_data: Uint8Array; // vec nat8 maps to Uint8Array in JS
  behavioral_data: string; // JSON string for behavioral data
}

// Corresponds to Candid: record VerificationResult
export interface VerificationResultUi {
  success: boolean;
  nft_id: [] | [string]; // opt text
  error_message: [] | [string]; // opt text
  verification_hash: [] | [string]; // opt text
}

// Corresponds to Candid: record NftMetadata
export interface NftMetadataUi {
  token_id: string;
  name: string;
  description: string;
  issued_at: bigint; // nat64
  verification_hash: string;
  owner: Principal;
  // challenge_level: [] | [string]; // Example for optional field
  // expiry_date: [] | [bigint]; // Example for optional field
}

// Corresponds to Candid: record { proof_data: text; public_input: text }
export interface ZkProofMockUi {
  proof_data: string;
  public_input: string;
}

// It's also good practice to define the interface for the actor (service)
// This would typically be auto-generated by dfx build, but good for reference
// and for creating a typed actor instance in frontend services.
export interface PopaiBackendActor {
  start_verification_challenge: () => Promise<VerificationChallengeUi>;
  submit_challenge_result: (
    submission: VerificationSubmissionUi,
  ) => Promise<VerificationResultUi>;
  get_nft_metadata: (token_id: string) => Promise<[] | [NftMetadataUi]>;
  generate_zk_proof_mock: (verification_hash: string) => Promise<ZkProofMockUi>;

  // Including existing methods from the template for completeness,
  // though the frontend might not use all of them for PoPAI.
  // Ensure ChatMessage type is defined if used, or use a generic type e.g. any[]
  chat: (messages: any[]) => Promise<string>;
  get_count: () => Promise<bigint>;
  greet: (name: string) => Promise<string>;
  increment: () => Promise<bigint>;
  prompt: (text: string) => Promise<string>;
  set_count: (count: bigint) => Promise<bigint>;
}

// Note: When `dfx generate` runs, it will create .did.js and .did.d.ts files
// in `src/declarations/popai_backend` (or similar based on dfx.json).
// Those auto-generated types are the source of truth for Candid <-> JS.
// These manually defined types here are for conceptual clarity and to guide
// frontend development before the first full `dfx deploy` or `dfx generate`.
// It's important to keep them in sync or prefer using the auto-generated ones
// once available by importing from the declarations folder.
// For example: import { NftMetadata as AutoGeneratedNftMetadata } from '../../declarations/popai_backend/popai_backend.did';
// Then you might not even need this shared_types folder, or it could hold more abstract/UI-specific types.
// For this task, we are creating them as requested.
